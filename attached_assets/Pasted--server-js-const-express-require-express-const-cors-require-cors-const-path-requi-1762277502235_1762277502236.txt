// server.js
const express = require('express');
const cors = require('cors');
const path = require('path');
const multer = require('multer');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const Database = require('better-sqlite3');
const fs = require('fs');
const DB_PATH = path.join(__dirname, 'data.db');
const db = new Database(DB_PATH);
const app = express();
const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET || 'troco-seguro';
// run migrations file if exists
try {
 const migrationsPath = path.join(__dirname, 'migrations.sql');
 if (fs.existsSync(migrationsPath)) {
 const migrations = fs.readFileSync(migrationsPath, 'utf8');
 db.exec(migrations);
 }
} catch (e) {
 console.error('Erro ao aplicar migrations:', e.message);
}
app.use(express.json());
app.use(cors({ origin: true, credentials: true }));
// static uploads
app.use('/uploads', express.static(path.join(__dirname, '..', 'uploads')));
function authMiddleware(requiredRole) {
 return (req, res, next) => {
 const token = req.headers.authorization?.split(' ')[1];
 if (!token) return res.status(401).json({ error: 'No token' });
 try {
 const payload = jwt.verify(token, JWT_SECRET);
 if (requiredRole && payload.role !== requiredRole) return
res.status(403).json({ error: 'Forbidden' });
 req.user = payload;
 next();
 } catch (e) {
 return res.status(401).json({ error: 'Invalid token' });
 }
 };
}
const getUserByMatricula = (matricula) => db.prepare('SELECT * FROM users
4
WHERE matricula = ?').get(matricula);
// Auth (user login by matricula)
app.post('/api/auth/login', (req, res) => {
 const { matricula } = req.body;
 if (!matricula) return res.status(400).json({ error: 'matricula
required' });
 const user = getUserByMatricula(matricula);
 if (!user) return res.status(404).json({ error: 'User not found' });
 const token = jwt.sign({ id: user.id, role: user.role, name:
user.full_name, matricula: user.matricula }, JWT_SECRET, { expiresIn:
'12h' });
 res.json({ token, role: user.role, name: user.full_name });
});
// Admin login (matricula + password)
app.post('/api/auth/admin-login', (req, res) => {
 const { matricula, password } = req.body;
 if (!matricula || !password) return res.status(400).json({ error:
'matricula and password required' });
 const user = getUserByMatricula(matricula);
 if (!user || user.role !== 'admin') return res.status(404).json({ error:
'Admin not found' });
 if (!bcrypt.compareSync(password, user.password_hash || '')) return
res.status(401).json({ error: 'Invalid password' });
 const token = jwt.sign({ id: user.id, role: user.role, name:
user.full_name, matricula: user.matricula }, JWT_SECRET, { expiresIn:
'12h' });
 res.json({ token, role: user.role, name: user.full_name });
});
// Admin: create users
app.post('/api/admin/users', authMiddleware('admin'), (req, res) => {
 const { full_name, matricula, role = 'user', password } = req.body;
 if (!full_name || !matricula) return res.status(400).json({ error: 'missing
fields' });
 const pwHash = password ? bcrypt.hashSync(password, 8) : null;
 try {
 const stmt = db.prepare('INSERT INTO users (full_name, matricula, role,
password_hash) VALUES (?, ?, ?, ?)');
 const info = stmt.run(full_name, matricula, role, pwHash);
 res.json({ id: info.lastInsertRowid });
 } catch (e) {
 res.status(400).json({ error: e.message });
 }
});
app.get('/api/admin/users', authMiddleware('admin'), (req, res) => {
 const rows = db.prepare('SELECT id, full_name, matricula, role, created_at
FROM users').all();
 res.json(rows);
5
});
// sectors
app.post('/api/admin/sectors', authMiddleware('admin'), (req, res) => {
 const { name } = req.body;
 if (!name) return res.status(400).json({ error: 'name required' });
 try {
 const info = db.prepare('INSERT INTO sectors (name) VALUES
(?)').run(name);
 res.json({ id: info.lastInsertRowid });
 } catch (e) {
 res.status(400).json({ error: e.message });
 }
});
app.get('/api/sectors', authMiddleware(), (req, res) => {
 res.json(db.prepare('SELECT * FROM sectors').all());
});
// upload
const upload = multer({ dest: path.join(__dirname, '..', 'uploads/') });
app.post('/api/admin/products', authMiddleware('admin'),
upload.single('photo'), (req, res) => {
 const { name, sector_id, unit_price = 0, stock_quantity = 0 } = req.body;
 const photo_path = req.file ? `/uploads/${req.file.filename}` : null;
 const stmt = db.prepare(`INSERT INTO products (name, sector_id, unit_price,
stock_quantity, total_in, photo_path)
 VALUES (?, ?, ?, ?, ?, ?)`);
 const info = stmt.run(name, sector_id || null, parseFloat(unit_price),
parseInt(stock_quantity||0), parseInt(stock_quantity||0), photo_path);
 db.prepare('INSERT INTO stock_transactions (product_id, change, reason)
VALUES (?, ?, ?)').run(info.lastInsertRowid, stock_quantity, 'initial');
 db.prepare('UPDATE products SET total_in = total_in + ? WHERE id
= ?').run(stock_quantity, info.lastInsertRowid);
 res.json({ id: info.lastInsertRowid });
});
app.get('/api/products', authMiddleware(), (req, res) => {
 const rows = db.prepare(`SELECT p.*, s.name as sector_name FROM products p
LEFT JOIN sectors s ON p.sector_id = s.id`).all();
 res.json(rows);
});
// finalize operation (user)
app.post('/api/operation/finalize', authMiddleware('user'), (req, res) => {
 const { items } = req.body;
 if (!Array.isArray(items) || items.length === 0) return
res.status(400).json({ error: 'items required' });
 const userId = req.user.id;
 const now = new Date().toISOString();
 const tx = db.transaction((items) => {
6
 for (const it of items) {
 const p = db.prepare('SELECT * FROM products WHERE id
= ?').get(it.productId);
 if (!p) throw new Error('Product not found: ' + it.productId);
 const qty = parseInt(it.qty || 1);
 if (p.stock_quantity - qty < 0) throw new Error(`Not enough stock for $
{p.name}`);
 db.prepare('UPDATE products SET stock_quantity = stock_quantity - ?,
total_out = total_out + ?, updated_at = CURRENT_TIMESTAMP WHERE id
= ?').run(qty, qty, it.productId);
 db.prepare('INSERT INTO consumptions (user_id, product_id, qty,
unit_price, total_price, consumed_at) VALUES (?, ?, ?, ?, ?, ?)').run(userId,
it.productId, qty, p.unit_price, qty * p.unit_price, now);
 db.prepare('INSERT INTO stock_transactions (product_id, change, reason)
VALUES (?, ?, ?)').run(it.productId, -qty, `consumption by user ${userId}`);
 }
 });
 try {
 tx(items);
 res.json({ ok: true, message: 'Operation finalized' });
 } catch (e) {
 res.status(400).json({ error: e.message });
 }
});
// reports
const ExcelJS = require('exceljs');
app.get('/api/reports/consumption', authMiddleware('admin'), (req, res) => {
 const { from, to, userId } = req.query;
 let stmt = `SELECT c.*, u.full_name, u.matricula, p.name as product_name
FROM consumptions c
 JOIN users u ON c.user_id = u.id
 JOIN products p ON c.product_id = p.id
 WHERE 1=1`;
 const params = [];
 if (userId) { stmt += ' AND c.user_id = ?'; params.push(userId); }
 if (from) { stmt += ' AND datetime(c.consumed_at) >= datetime(?)';
params.push(from); }
 if (to) { stmt += ' AND datetime(c.consumed_at) <= datetime(?)';
params.push(to); }
 stmt += ' ORDER BY c.consumed_at DESC';
 const rows = db.prepare(stmt).all(...params);
 res.json(rows);
});
app.get('/api/reports/consumption/export', authMiddleware('admin'), async
(req, res) => {
 const { from, to, userId } = req.query;
 const rows = db.prepare(`SELECT c.*, u.full_name, u.matricula, p.name as
product_name FROM consumptions c
 JOIN users u ON c.user_id = u.id
7
 JOIN products p ON c.product_id = p.id
 WHERE (? IS NULL OR c.user_id = ?) AND (? IS NULL OR
datetime(c.consumed_at) >= datetime(?)) AND (? IS NULL OR
datetime(c.consumed_at) <= datetime(?))
 ORDER BY c.consumed_at DESC`).all(userId||null, userId||null, from||null,
from||null, to||null, to||null);
 const workbook = new ExcelJS.Workbook();
 const sheet = workbook.addWorksheet('consumption');
 sheet.columns = [
 { header: 'User', key: 'full_name', width: 30 },
 { header: 'Matricula', key: 'matricula', width: 15 },
 { header: 'Date', key: 'consumed_at', width: 20 },
 { header: 'Product', key: 'product_name', width: 30 },
 { header: 'Qty', key: 'qty', width: 10 },
 { header: 'Unit Price', key: 'unit_price', width: 12 },
 { header: 'Total', key: 'total_price', width: 12 },
 ];
 rows.forEach(r => sheet.addRow(r));
 res.setHeader('Content-Type', 'application/vnd.openxmlformatsofficedocument.spreadsheetml.sheet');
 res.setHeader('Content-Disposition', `attachment; filename=consumption-$
{Date.now()}.xlsx`);
 await workbook.xlsx.write(res);
 res.end();
});
app.get('/api/reports/stock', authMiddleware('admin'), (req, res) => {
 const rows = db.prepare('SELECT p.*, s.name as sector_name FROM products p
LEFT JOIN sectors s ON p.sector_id = s.id').all();
 res.json(rows);
});
// serve frontend build if exists
app.use(express.static(path.join(__dirname, '..', 'client', 'dist')));
app.get('*', (req, res) => {
 res.sendFile(path.join(__dirname, '..', 'client', 'dist', 'index.html'));
});
app.listen(PORT, () => console.log('Server running on', PORT));